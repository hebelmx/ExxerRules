---
description: Get best practices for Entity Framework Core
globs: 
alwaysApply: false
---
**mode**: 'agent'
**Objective**: 'Get best practices for XUnit unit testing, including data-driven tests'
---

# XUnit Best Practices

Your goal is to help me write effective unit tests with XUnit, covering both standard and data-driven testing approaches.

## Project Setup

- Use a separate test project with naming convention `[ProjectName].Tests`
- Reference Microsoft.NET.Test.Sdk, xunit, and xunit.runner.visualstudio packages
- Create test classes that match the classes being tested (e.g., `CalculatorTests` for `Calculator`)
- Use .NET SDK test commands: `dotnet test` for running tests

## Test Structure

- No test class attributes required (unlike MSTest/NUnit)
- Use fact-based tests with `[Fact]` attribute for simple tests
- Follow the Arrange-Act-Assert (AAA) pattern
- Name tests using the pattern `MethodName_Scenario_ExpectedBehavior`
- Use constructor for setup and `IDisposable.Dispose()` for teardown
- Use `IClassFixture<T>` for shared context between tests in a class
- Use `ICollectionFixture<T>` for shared context between multiple test classes

## Standard Tests

- Keep tests focused on a single behavior
- Avoid testing multiple behaviors in one test method
- Use clear assertions that express intent
- Include only the assertions needed to verify the test case
- Make tests independent and idempotent (can run in any order)
- Avoid test interdependencies

## Data-Driven Tests

- Use `[Theory]` combined with data source attributes
- Use `[InlineData]` for inline test data
- Use `[MemberData]` for method-based test data
- Use `[ClassData]` for class-based test data
- Create custom data attributes by implementing `DataAttribute`
- Use meaningful parameter names in data-driven tests

## Assertions with Shouldly

- Prefer `Shouldly` over `Assert.*` for improved readability and diagnostics
- Avoid mixing `Assert` and `Shouldly` in the same test method
- Use fluent assertions that clearly express intent

- Core Assertions
	- `value.ShouldBe(expected)` for value equality
	- `object.ShouldBeSameAs(expected)` for reference equality
	- `object.ShouldNotBeSameAs(unexpected)` for reference inequality
	- `condition.ShouldBeTrue()` / `condition.ShouldBeFalse()` for booleans
	- `object.ShouldBeNull()` / `object.ShouldNotBeNull()` for null checks
- Collection Assertions
	- `collection.ShouldBeEmpty()` or `ShouldNotBeEmpty()`
	- `collection.ShouldContain(item)` / `ShouldNotContain(item)`
	- `collection.ShouldBeSubsetOf(superSet)`
- String Assertions
	- `text.ShouldContain("substring")` / `ShouldNotContain("substring")`
	- `text.ShouldStartWith("prefix")` / `ShouldEndWith("suffix")`
	- `text.ShouldBeNullOrEmpty()` / `ShouldBeNullOrWhiteSpace()`

- Numeric Assertions
	- `number.ShouldBeGreaterThan(value)` / `ShouldBeLessThan(value)`
	- `number.ShouldBeInRange(min, max)`

- DateTime Assertions

	- `dateTime.ShouldBeInRange(start, end)`

- Exception Assertions

	- `Should.Throw<ExceptionType>(() => action())`
	- `await Should.ThrowAsync<ExceptionType>(async () => await actionAsync())`


## Mocking and Isolation with NSubstitute

- Use `NSubstitute` for creating and configuring mocks
- Prefer mocking via interfaces or virtual members
- Create substitutes using `Substitute.For<T>()`
- Use `Returns(...)` to define return values
- Use `Received()` to assert calls were made
- Use `DidNotReceive()` to assert calls were not made
- Mock async methods with `Returns(Task.FromResult(...))` or `ReturnsAsync(...)`
- Consider using a DI container for complex test setups

- Basic Examples

	```csharp
	var service = Substitute.For<IMyService>();
	service.DoWork().Returns("done");

	var result = service.DoWork();

	result.ShouldBe("done");
	service.Received(1).DoWork();

## Test Organization

- Group tests by feature or component
- Use `[Trait("Category", "CategoryName")]` for categorization
- Use collection fixtures to group tests with shared dependencies
- Consider output helpers (`ITestOutputHelper`) for test diagnostics
- Skip tests conditionally with `Skip = "reason"` in fact/theory attributes
